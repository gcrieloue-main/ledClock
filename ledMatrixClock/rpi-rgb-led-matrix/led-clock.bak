// -*- mode: c++; c-basic-offset: 2; indent-tabs-mode: nil; -*-
// Small example how write text.
//
// This code is public domain
// (but note, that the led-matrix library this depends on is GPL v2)

#include "led-matrix.h"
#include "graphics.h"
#include "socket.h"

#include <iostream>
#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ctime>
#include <vector>
#include <sstream>

using namespace rgb_matrix;

static int usage(const char *progname) {
    fprintf(stderr, "usage: %s [options]\n", progname);
    fprintf(stderr, "Reads text from stdin and displays it. "
            "Empty string: clear screen\n");
    fprintf(stderr, "Options:\n"
            "\t-f <font-file>: Use given font.\n"
            "\t-r <rows>     : Display rows. 16 for 16x32, 32 for 32x32. "
            "Default: 32\n"
            "\t-P <parallel> : For Plus-models or RPi2: parallel chains. 1..3. "
            "Default: 1\n"
            "\t-c <chained>  : Daisy-chained boards. Default: 1.\n"
            "\t-x <x-origin> : X-Origin of displaying text (Default: 0)\n"
            "\t-y <y-origin> : Y-Origin of displaying text (Default: 0)\n"
            "\t-C <r,g,b>    : Color. Default 255,255,0\n");
    return 1;
}

std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}


std::vector<std::string> split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, elems);
    return elems;
}

static bool parseColor(Color *c, const char *str) {
    return sscanf(str, "%hhu,%hhu,%hhu", &c->r, &c->g, &c->b) == 3;
}


void drawLineAnimated(RGBMatrix* canvas, bool orientation, bool direction, int x1, int y1, int length, int r, int g, int b)
{
    FrameCanvas* frame = canvas->SwapOnVSync(NULL);

    if (orientation) //horizontal
    {
        if (direction)
        {
            for (int x=x1;x<x1+length;x++)
            {
                frame->SetPixel(x,y1,r,g,b);
                usleep(20*1000);
            }
        }
        else 
        {
            for (int x=x1;x>x1-length;x--)
            {
                frame->SetPixel(x,y1,r,g,b);
                usleep(20*1000);
            }
        }
    }
    else //vertical
    {
        if (direction)
        {
            for (int y=y1;y<y1+length;y++)
            {
                frame->SetPixel(x1,y,r,g,b);
                usleep(20*1000);
            }
        }
        else
        {
            for (int y=y1;y>y1-length;y--)
            {
                frame->SetPixel(x1,y,r,g,b);
                usleep(20*1000);
            }
        }
    }
}

void spiraleAnimate(RGBMatrix * canvas, const Color &c)
{
    drawLineAnimated(canvas, false, false,  0, 15, 16, c.r,c.g,c.b );
    drawLineAnimated(canvas, true, true,  0, 0, 31, c.r,c.g,c.b );
    drawLineAnimated(canvas, false, true,  31, 0, 16, c.r,c.g,c.b );
    drawLineAnimated(canvas, true, false,  31, 15, 31, c.r,c.g,c.b );

    drawLineAnimated(canvas, false, false,  1, 15, 15, c.r,c.g,c.b );
    drawLineAnimated(canvas, true, true,  1, 1, 30, c.r,c.g,c.b );
    drawLineAnimated(canvas, false, true,  30, 1, 15, c.r,c.g,c.b );
    drawLineAnimated(canvas, true, false,  30, 14, 30, c.r,c.g,c.b );

    drawLineAnimated(canvas, false, false,  2, 14, 14, c.r,c.g,c.b );
    drawLineAnimated(canvas, true, true,  2, 2, 29, c.r,c.g,c.b );
    drawLineAnimated(canvas, false, true,  29, 2, 14, c.r,c.g,c.b );
    drawLineAnimated(canvas, true, false,  29, 13, 29, c.r,c.g,c.b );
}

void randomizeAnimate(RGBMatrix * canvas, const Color &c)
{
    int nbPoints = 20;
    int duration = 200;
    int delay = 20*1000;

    canvas->Clear();
    for (int i=0;i<duration;i++)
    {
        FrameCanvas* frame = canvas->CreateFrameCanvas();
        for (int x=0;x<nbPoints;x++)
        {
            for (int y=0;y<16;y++)
            {
                frame->SetPixel(rand()%32,rand()%16,c.r,c.g,c.b);
            }
        }
        canvas->SwapOnVSync(frame);
        usleep(delay);
    }
    canvas->Clear();
}

void hourAnimate(RGBMatrix * currentFrame, const Color &c, bool opening)
{
    // sm200all animation
    int r = 80;
    int g = 0;
    int b = 0;

    if (opening)
    {
        for (int i=0;i<14;i++){
            currentFrame->SetPixel(16+i,3,r,g,b);
            currentFrame->SetPixel(15-i,3,r,g,b);
            currentFrame->SetPixel(16+i,12,r,g,b);
            currentFrame->SetPixel(15-i,12,r,g,b);
            usleep(20*1000);
        }
    }
    if (!opening)
    {
        r=0;
        g=0;
        b=0;
        for (int i=0;i<14;i++){
            currentFrame->SetPixel(16+i,3,r,g,b);
            currentFrame->SetPixel(15-i,3,r,g,b);
            currentFrame->SetPixel(16+i,12,r,g,b);
            currentFrame->SetPixel(15-i,12,r,g,b);
            usleep(20*1000);
        }
    }
}

void coolBorderAnimate(RGBMatrix * currentFrame, const Color &c, bool opening)
{
    // sm200all animation
    int ycpt = 0, xcpt=0;
    int r = c.r;
    int g = c.g;
    int b = c.b;


    if (opening)
    {
        while (ycpt!=16)
        {
            currentFrame->SetPixel(15+ycpt,0,r,g,b);
            currentFrame->SetPixel(15-ycpt,0,r,g,b);
            currentFrame->SetPixel(15+ycpt,15,r,g,b);
            currentFrame->SetPixel(15-ycpt,15,r,g,b);
            ycpt++;
            usleep(20*1000);
        }
        while (xcpt!=8)
        {
            currentFrame->SetPixel(0,xcpt,r,g,b);
            currentFrame->SetPixel(0,15-xcpt,r,g,b);
            currentFrame->SetPixel(31,xcpt,r,g,b);
            currentFrame->SetPixel(31,15-xcpt,r,g,b);
            xcpt++;
            usleep(20*1000);
        }
    }
    if (!opening)
    {
        ycpt=16;
        xcpt=8;
        r=0;
        g=0;
        b=0;
        while (xcpt!=0)
        {
            currentFrame->SetPixel(0,xcpt,r,g,b);
            currentFrame->SetPixel(0,15-xcpt,r,g,b);
            currentFrame->SetPixel(31,xcpt,r,g,b);
            currentFrame->SetPixel(31,15-xcpt,r,g,b);
            xcpt--;
            usleep(20*1000);
        }
        while (ycpt!=-1)
        {
            currentFrame->SetPixel(15+ycpt,0,r,g,b);
            currentFrame->SetPixel(15-ycpt,0,r,g,b);
            currentFrame->SetPixel(15+ycpt,15,r,g,b);
            currentFrame->SetPixel(15-ycpt,15,r,g,b);
            ycpt--;
            usleep(20*1000);
        }
    }
}

void scrollText(RGBMatrix* canvas, const Color &color, const rgb_matrix::Font& font, const char* text)
{
    FrameCanvas* frame = canvas->SwapOnVSync(NULL);
    int len = strlen(text);
    int pixelLength = len * font.CharacterWidth('X')+32;
    for (int i=0;i<pixelLength;i++) {
        canvas->Clear();
        rgb_matrix::DrawText(frame, font, 32-i, 4+font.baseline(), color, text);
        usleep(30*1000);
    }
}

std::string pop_front(std::vector<std::string>& vec)
{
    std::string text = vec.front();
    vec.erase(vec.begin());
    return text;
}

void* commandListenerThread(void* vector)
{
    std::vector<std::string>* myVector = (std::vector<std::string>*)vector;
    CommandListener* commandListener = new CommandListener(*myVector);
    commandListener->startSocket(); 
    pthread_exit(NULL);
}

void handleCommand(RGBMatrix* canvas, std::vector<std::string>& myVector, rgb_matrix::Font& font, Color& color, const int x, const int y)
{
    std::string text = pop_front(myVector);
    std::cout<<"display : "<<text<<std::endl;
    canvas->Clear();
    if (text.find(":")!=std::string::npos)
    {
        std::vector<std::string> sp = split(text, ':');
        if (sp.front()=="bright")
        {
            int brightness = atoi(sp.at(1).c_str());
            canvas->SetBrightness(brightness);
        }
        else if (sp.front()=="color")
        {
            int r = atoi(sp.at(1).c_str());
            int g = atoi(sp.at(2).c_str());
            int b = atoi(sp.at(3).c_str());
            color.r = r;
            color.g = g;
            color.b = b;
        }
        else if (sp.front()=="text")
        {
            const char* content = sp.at(1).c_str();
            int repetition = atoi(sp.at(2).c_str());
            for (int i=0;i<repetition;i++)
            {
                scrollText(canvas, color, font, content);
            }
        }
        else if (sp.front()=="animate")
        {
            const char* content = sp.at(1).c_str();
            if (strcmp(content,"randomize")==0)
            {
                randomizeAnimate(canvas, color);
            }
        }
    }
    else
    {
        if (text.length()<=5)
        {
            rgb_matrix::DrawText(canvas, font, x, y + font.baseline(), color, text.c_str());
            sleep(2);
        }
        else
        {
            scrollText(canvas, color, font, text.c_str());
        }
        canvas->Clear();
    }
}

int main(int argc, char *argv[]) {
    // Constant settings
    int rows = 16;
    int chain = 1;
    int parallel = 1;

    // Default settings
    Color color(80,80,80);
    int brightness = 70;
    int x_orig = 1;
    int y_orig = 4;
    const char *bdf_font_file = "fonts/6x9.bdf";

    int opt;
    while ((opt = getopt(argc, argv, "x:y:f:C:")) != -1) {
        switch (opt) {
            case 'x': x_orig = atoi(optarg); break;
            case 'y': y_orig = atoi(optarg); break;
            case 'f': bdf_font_file = strdup(optarg); break;
            case 'C':
                      if (!parseColor(&color, optarg)) {
                          fprintf(stderr, "Invalid color spec.\n");
                          return usage(argv[0]);
                      }
                      break;
            default:
                      return usage(argv[0]);
        }
    }

    if (bdf_font_file == NULL) {
        fprintf(stderr, "Need to specify BDF font-file with -f\n");
        return usage(argv[0]);
    }

    /*
     * Load font. This needs to be a filename with a bdf bitmap font.
     */
    rgb_matrix::Font font;
    if (!font.LoadFont(bdf_font_file)) {
        fprintf(stderr, "Couldn't load font '%s'\n", bdf_font_file);
        return usage(argv[0]);
    }

    /*
     * Set up GPIO pins. This fails when not running as root.
     */
    GPIO io;
    if (!io.Init())
        return 1;

    /*
     * Set up the RGBMatrix. It implements a 'Canvas' interface.
     */
    RGBMatrix *canvas = new RGBMatrix(&io, rows, chain, parallel);

    bool all_extreme_colors = true;
    all_extreme_colors &= color.r == 0 || color.r == 255;
    all_extreme_colors &= color.g == 0 || color.g == 255;
    all_extreme_colors &= color.b == 0 || color.b == 255;
    if (all_extreme_colors)
        canvas->SetPWMBits(1);

    const int x = x_orig;
    int y = y_orig;

    spiraleAnimate(canvas, color);
    canvas->SetBrightness(brightness);
    canvas->Clear();

    scrollText(canvas,color,font,"GCR CUSTOM CLOCK");

    std::vector<std::string> myVector;
    pthread_t thread;

    if(pthread_create(&thread, NULL, commandListenerThread, &myVector) == -1) {
        perror("pthread_create");
        std::cout<<"busy socket"<<std::endl;
    }

    int previousMinute = 0;
    while (1)
    {
        if (!myVector.empty())
        {
            handleCommand(canvas, myVector, font, color, x, y);
        }
        else
        {

            time_t now = time(0);
            tm *lt = localtime(&now);
            char date[5];
            if (lt->tm_min != previousMinute)
            {
                canvas->Clear();
                coolBorderAnimate(canvas, color, true);
            }
            sprintf(date, "%02d:%02d", lt->tm_hour, lt->tm_min);
            rgb_matrix::DrawText(canvas, font, x, y + font.baseline(), color, date);
            if (lt->tm_min != previousMinute)
            {
                coolBorderAnimate(canvas, color, false);
                if (lt->tm_min == 0 || lt->tm_min == 15 || lt->tm_min == 30 || lt->tm_min == 45)
                {
                    hourAnimate(canvas, color, true);
                    hourAnimate(canvas, color, false);
                }
                previousMinute = lt->tm_min;
            }
            sleep(0.2);
        }
    }

    // Finished. Shut down the RGB matrix.
    delete canvas;

    return 0;
}

